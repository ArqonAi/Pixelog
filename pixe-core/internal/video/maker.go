package video

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"image"
	"image/png"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	"github.com/ArqonAi/Pixelog/internal/qr"
	"github.com/ArqonAi/Pixelog/pkg/config"
	"github.com/makiuchi-d/gozxing"
	qrReader "github.com/makiuchi-d/gozxing/qrcode"
)

type Maker struct{}

type Metadata struct {
	Version     string         `json:"version"`
	CreatedAt   string         `json:"created_at"`
	TotalChunks int            `json:"total_chunks"`
	Contents    []ContentItem  `json:"contents"`
	Config      *config.Config `json:"config"`
}

type ContentItem struct {
	Name      string `json:"name"`
	Type      string `json:"type"`
	Size      string `json:"size"`
	Hash      string `json:"hash"`
	CreatedAt string `json:"created_at"`
}

func New() (*Maker, error) {
	// Check if ffmpeg is available
	if _, err := exec.LookPath("ffmpeg"); err != nil {
		return nil, fmt.Errorf("ffmpeg not found in PATH: %w", err)
	}

	return &Maker{}, nil
}

func (m *Maker) CreateVideo(framePaths []string, outputPath string, metadata interface{}, cfg *config.Config) error {
	if len(framePaths) == 0 {
		return fmt.Errorf("no frames to process")
	}

	// Create a temporary directory for the frame sequence
	tempDir := filepath.Dir(framePaths[0])

	// Create metadata file
	metadataPath := filepath.Join(tempDir, "metadata.json")
	metadataData, err := json.MarshalIndent(metadata, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal metadata: %w", err)
	}

	if err := os.WriteFile(metadataPath, metadataData, 0644); err != nil {
		return fmt.Errorf("failed to write metadata: %w", err)
	}

	// Build ffmpeg command
	args := []string{
		"-y", // Overwrite output file
		"-framerate", fmt.Sprintf("%.2f", cfg.FrameRate),
		"-i", filepath.Join(tempDir, "frame_%05d.png"),
		"-f", "lavfi", "-i", "anullsrc=channel_layout=stereo:sample_rate=48000",
		"-c:v", "libx264",
		"-pix_fmt", "yuv420p",
		"-crf", strconv.Itoa(cfg.Quality),
		"-preset", "medium",
		"-c:a", "aac",
		"-b:a", "128k",
		"-shortest",
		"-movflags", "+faststart",
		"-metadata", "title=Pixelog Knowledge File",
		"-metadata", "comment=Generated by Pixelog v1.0.0",
		"-f", "mp4", // Force MP4 format for .pixe files
		outputPath,
	}

	cmd := exec.Command("ffmpeg", args...)

	if cfg.Verbose {
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
	}

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("ffmpeg command failed: %w", err)
	}

	// Clean up metadata file
	os.Remove(metadataPath)

	return nil
}

func (m *Maker) ExtractData(inputPath, outputDir string) error {
	// Create temporary directory for frames
	tempDir, err := os.MkdirTemp("", "pixelog-extract-*")
	if err != nil {
		return fmt.Errorf("failed to create temp directory: %w", err)
	}
	defer os.RemoveAll(tempDir)

	// Extract frames from video using FFmpeg
	// -vsync 0 extracts ALL frames without resampling
	framePattern := filepath.Join(tempDir, "frame_%05d.png")
	cmd := exec.Command("ffmpeg", "-i", inputPath, "-vsync", "0", framePattern)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to extract frames: %w", err)
	}

	// Find all extracted frames
	frameFiles, err := filepath.Glob(filepath.Join(tempDir, "frame_*.png"))
	if err != nil {
		return fmt.Errorf("failed to find frames: %w", err)
	}

	if len(frameFiles) == 0 {
		return fmt.Errorf("no frames extracted from video")
	}

	// Sort frames by filename to ensure correct order
	sort.Strings(frameFiles)

	// Decode QR codes from each frame
	var allChunks []qr.Chunk
	for i, frameFile := range frameFiles {
		chunk, err := m.decodeQRFromFrame(frameFile, i)
		if err != nil {
			// Skip frames that don't contain valid QR codes
			continue
		}
		allChunks = append(allChunks, *chunk)
	}

	if len(allChunks) == 0 {
		return fmt.Errorf("no valid QR codes found in video frames")
	}

	// Sort chunks by index to ensure correct reassembly
	sort.Slice(allChunks, func(i, j int) bool {
		return allChunks[i].Index < allChunks[j].Index
	})

	// Group chunks by file (using Hash as file identifier)
	fileChunks := make(map[string][]qr.Chunk)
	for _, chunk := range allChunks {
		fileChunks[chunk.Hash] = append(fileChunks[chunk.Hash], chunk)
	}

	// Reassemble each file
	for _, chunks := range fileChunks {
		if len(chunks) == 0 {
			continue
		}

		// Sort chunks by index
		sort.Slice(chunks, func(i, j int) bool {
			return chunks[i].Index < chunks[j].Index
		})

		// Verify we have all chunks and check for index consistency
		if len(chunks) == 0 {
			return fmt.Errorf("no chunks found")
		}
		
		firstChunk := chunks[0]
		expectedTotal := firstChunk.Total
		actualTotal := len(chunks)
		
		fmt.Printf("DEBUG: Chunk validation - Expected: %d, Actual: %d\n", expectedTotal, actualTotal)
		
		// Check if all chunk indices are present (0-based indexing) and deduplicate
		indexMap := make(map[int]bool)
		uniqueChunks := make(map[int]qr.Chunk)
		for _, chunk := range chunks {
			fmt.Printf("DEBUG: Chunk %d/%d: Index=%d, Data length=%d\n", chunk.Index, chunk.Total, chunk.Index, len(chunk.Data))
			indexMap[chunk.Index] = true
			uniqueChunks[chunk.Index] = chunk // This automatically deduplicates by index
		}
		
		// Replace chunks with deduplicated version
		chunks = make([]qr.Chunk, 0, len(uniqueChunks))
		for i := 0; i < expectedTotal; i++ {
			if chunk, exists := uniqueChunks[i]; exists {
				chunks = append(chunks, chunk)
			}
		}
		
		// Verify all indices from 0 to Total-1 are present
		for i := 0; i < expectedTotal; i++ {
			if !indexMap[i] {
				return fmt.Errorf("missing chunk index %d for file %s", i, firstChunk.SourceFile)
			}
		}
		
		if actualTotal != expectedTotal {
			fmt.Printf("DEBUG: Chunk count mismatch for %s - this might be OK if chunks are duplicated\n", firstChunk.SourceFile)
			// Instead of failing, let's use only the unique chunks we need
		}

		// Reassemble file data
		var reassembledData strings.Builder
		for _, chunk := range chunks {
			reassembledData.WriteString(chunk.Data)
		}

		// Decode data based on MIME type
		var finalData []byte
		if strings.HasPrefix(firstChunk.MimeType, "text/") {
			finalData = []byte(reassembledData.String())
		} else {
			// Decode base64 for binary files
			decoded, err := base64.StdEncoding.DecodeString(reassembledData.String())
			if err != nil {
				return fmt.Errorf("failed to decode base64 data for %s: %w", firstChunk.SourceFile, err)
			}
			finalData = decoded
		}

		// Write reassembled file
		outputPath := filepath.Join(outputDir, firstChunk.SourceFile)
		if err := os.WriteFile(outputPath, finalData, 0644); err != nil {
			return fmt.Errorf("failed to write extracted file %s: %w", outputPath, err)
		}
	}

	return nil
}

func (m *Maker) decodeQRFromFrame(framePath string, frameIndex int) (*qr.Chunk, error) {
	// Open and decode the PNG frame
	file, err := os.Open(framePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open frame %s: %w", framePath, err)
	}
	defer file.Close()

	img, err := png.Decode(file)
	if err != nil {
		return nil, fmt.Errorf("failed to decode PNG frame %s: %w", framePath, err)
	}

	// Convert image to grayscale for QR decoding
	bounds := img.Bounds()
	gray := image.NewGray(bounds)
	for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
		for x := bounds.Min.X; x < bounds.Max.X; x++ {
			gray.Set(x, y, img.At(x, y))
		}
	}

	// Try to decode QR code from the image
	// Note: This is a simplified approach. In production, you'd want to use a proper QR decoder library
	// For now, we'll implement a basic pattern matching approach
	qrData, err := m.extractQRData(gray)
	if err != nil {
		return nil, fmt.Errorf("failed to decode QR from frame %d: %w", frameIndex, err)
	}

	// Parse the QR data back into a chunk
	var chunk qr.Chunk
	if err := json.Unmarshal([]byte(qrData), &chunk); err != nil {
		return nil, fmt.Errorf("failed to parse QR data from frame %d: %w", frameIndex, err)
	}

	return &chunk, nil
}

func (m *Maker) extractQRData(img image.Image) (string, error) {
	// Convert image to gozxing BinaryBitmap
	bmp, err := gozxing.NewBinaryBitmapFromImage(img)
	if err != nil {
		return "", fmt.Errorf("failed to create bitmap: %w", err)
	}

	// Create QR code reader
	reader := qrReader.NewQRCodeReader()
	
	// Decode the QR code
	result, err := reader.Decode(bmp, nil)
	if err != nil {
		return "", fmt.Errorf("failed to decode QR code: %w", err)
	}

	return result.GetText(), nil
}

func (m *Maker) ExtractMetadata(inputPath string) (*Metadata, error) {
	// Extract metadata from video file using ffprobe
	cmd := exec.Command("ffprobe", "-v", "quiet", "-print_format", "json", "-show_format", inputPath)
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to extract metadata with ffprobe: %w", err)
	}

	// Parse ffprobe output
	var probeResult struct {
		Format struct {
			Tags struct {
				Title   string `json:"title"`
				Comment string `json:"comment"`
			} `json:"tags"`
		} `json:"format"`
	}

	if err := json.Unmarshal(output, &probeResult); err != nil {
		return nil, fmt.Errorf("failed to parse ffprobe output: %w", err)
	}

	// For now, return basic metadata
	// In a full implementation, you'd extract the embedded metadata from the video
	metadata := &Metadata{
		Version:     "1.0.0",
		CreatedAt:   "unknown",
		TotalChunks: 0,
		Contents:    []ContentItem{},
		Config:      nil,
	}

	return metadata, nil
}
